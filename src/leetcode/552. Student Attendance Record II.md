# 552. Student Attendance Record II

### 1. 문제 요약

- `A`, `L`, `P` 세 문자만을 이용해 문자열을 만든다.
- `A`는 최대 한번만 나타날 수 있고, `L`은 연속해서 최대 두번만 나타날 수 있다.
- 이러한 제약 조건을 만족하는 문자열의 개수를 반환하라.

<br>

### 2. 접근법: 다이나믹 프로그래밍

- 이 문제는 동적 프로그래밍을 사용하여 해결할 수 있다.  
- 해결을 위해 `dp[i][j][k]`라는 3차원 배열을 사용한다. 
- 여기서 `i`는 문자열의 길이, `j`는 `A`의 개수, `k`는 마지막에 연속으로 나타난 `L`의 개수를 나타낸다.  
- `dp[i][j][k]`는 길이가 `i`이고, `A`의 개수가 `j`이며, 마지막에 연속으로 나타난 `L`의 개수가 `k`인 문자열의 개수를 저장한다.  
- 이제 각 문자를 추가하는 경우를 고려해보자.  
1. `P`를 추가하는 경우
   - 'P'는 언제든지 추가할 수 있으므로, `dp[i][j][0]`는 이전 문자열의 모든 경우의 수를 더한 것과 같다. 
   - 즉, `dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1] + dp[i - 1][j][2]`이다.  
2. `A`를 추가하는 경우
   - `A`는 문자열에 최대 한 번만 나타날 수 있으므로, `j = 0`인 경우에만 `A`를 추가할 수 있다. 
   - 따라서 `dp[i][1][0] = dp[i - 1][0][0] + dp[i - 1][0][1] + dp[i - 1][0][2]`있다.  
3. `L`를 추가하는 경우
   - 'L'은 연속해서 최대 두 번만 나타날 수 있으므로, k가 2보다 작은 경우에만 `L`를 추가할 수 있다. 
   - 따라서 `dp[i][j][k] = dp[i - 1][j][k - 1]`입니다.  
- 이렇게 각 경우를 계산한 후, 모든 `j`와 `k`에 대해 `dp[n][j][k]`를 더하면, 길이가 `n`인 문자열에서 `A`가 최대 한 번, `L`이 연속해서 최대 두 번 나타나는 문자열의 개수를 구할 수 있다. 
- 이 값을 `1,000,000,007`로 나눈 나머지를 반환하면 된다.

<br>

### 3. 복잡도

- 시간 복잡도: `O(N)`
- 공간 복잡도: `O(N)`

<br>

### 4. 코드

``` Java
public class Solution {
    int mod = 1000000007;

    public int checkRecord(int n) {
        long[][][] dp = new long[n + 1][2][3];
        dp[0][0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < 2; j++) {
                for (int k = 0; k < 3; k++) {
                    // P
                    dp[i][j][0] += dp[i - 1][j][k] % mod;

                    // A
                    if (j > 0)
                        dp[i][j][0] += dp[i - 1][j - 1][k] % mod;

                    // L
                    if (k > 0)
                        dp[i][j][k] += dp[i - 1][j][k - 1] % mod;

                }
            }
        }
        long sum = 0;
        for (int j = 0; j < 2; j++) {
            for (int k = 0; k < 3; k++) {
                sum = (sum + dp[n][j][k]) % mod;
            }
        }
        return (int) sum;
    }
}

```
